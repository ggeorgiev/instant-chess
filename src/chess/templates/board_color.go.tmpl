package chess

import "github.com/ggeorgiev/instant-chess/src/square"

func (board Board) SquareUnderAttackFrom{Color}(s square.Index) bool {
	attackedFromKing := AttackedFromKing[s]
	for _, kingSquare := range attackedFromKing {
		if board[kingSquare] == {Color}King {
			return true
		}
	}

	attackedFromKnight := AttackedFromKnight[s]
	for _, knightSquare := range attackedFromKnight {
		if board[knightSquare] == {Color}Knight {
			return true
		}
	}

	x := s.X()
	y := s.Y()

	for i := x - 1; i >= 0; i-- {
		peace := board[square.NewIndex(i, y)]
		if peace.Is{Color}LinearMover() {
			return true
		}
		if peace != Empty {
			break
		}
	}
	for i := x + 1; i < 8; i++ {
		peace := board[square.NewIndex(i, y)]
		if peace.Is{Color}LinearMover() {
			return true
		}
		if peace != Empty {
			break
		}
	}
	for i := y - 1; i >= 0; i-- {
		peace := board[square.NewIndex(x, i)]
		if peace.Is{Color}LinearMover() {
			return true
		}
		if peace != Empty {
			break
		}
	}
	for i := y + 1; i < 8; i++ {
		peace := board[square.NewIndex(x, i)]
		if peace.Is{Color}LinearMover() {
			return true
		}
		if peace != Empty {
			break
		}
	}

	i := x - 1
	j := y - 1
	for i >= 0 && j >= 0 {
		peace := board[square.NewIndex(i, j)]
		if peace.Is{Color}DiagonalMover() {
			return true
		}
		if peace != Empty {
			break
		}
		i--
		j--
	}

	i = x - 1
	j = y + 1
	for i >= 0 && j < 8 {
		peace := board[square.NewIndex(i, j)]
		if peace.Is{Color}DiagonalMover() {
			return true
		}
		if peace != Empty {
			break
		}
		i--
		j++
	}

	i = x + 1
	j = y - 1
	for i < 8 && j >= 0 {
		peace := board[square.NewIndex(i, j)]
		if peace.Is{Color}DiagonalMover() {
			return true
		}
		if peace != Empty {
			break
		}
		i++
		j--
	}

	i = x + 1
	j = y + 1
	for i < 8 && j < 8 {
		peace := board[square.NewIndex(i, j)]
		if peace.Is{Color}DiagonalMover() {
			return true
		}
		if peace != Empty {
			break
		}
		i++
		j++
	}

	return false
}

func (board Board) {Color}KingTos(s square.Index) square.Indexes {
	var tos square.Indexes

	original := board[s]
	board[s] = Empty

	kingMoves := KingMoves[s]

	for _, square := range kingMoves {
		peace := board[square]
		if peace.IsEmptyOr{OponentColor}() && !board.SquareUnderAttackFrom{OponentColor}(square) {
			tos = append(tos, square)
		}
	}

	board[s] = original
	return tos
}

func (board Board) {Color}KnightTos(s square.Index, ks square.Index) square.Indexes {
	var tos square.Indexes

	check := func(square square.Index) {
		peace := board[square]
		if peace.IsEmptyOr{OponentColor}() {
			original := board[square]
			board[square] = board[s]
			board[s] = Empty

			if !board.SquareUnderAttackFrom{OponentColor}(ks) {
				tos = append(tos, square)
			}

			board[s] = board[square]
			board[square] = original
		}
	}

	knightMoves := KnightMoves[s]

	for _, square := range knightMoves {
		check(square)
	}

	return tos
}

func (board Board) {Color}RookTos(s square.Index, ks square.Index) square.Indexes {
	var tos square.Indexes

	check := func(square square.Index) bool {
		peace := board[square]
		if peace.IsEmptyOr{OponentColor}() {
			original := board[square]
			board[square] = board[s]
			board[s] = Empty

			if !board.SquareUnderAttackFrom{OponentColor}(ks) {
				tos = append(tos, square)
			}

			board[s] = board[square]
			board[square] = original
		}
		return peace.IsEmpty()
	}

	x := s.X()
	y := s.Y()

	for i := x - 1; i >= 0; i-- {
		if !check(square.NewIndex(i, y)) {
			break
		}
	}
	for i := x + 1; i < 8; i++ {
		if !check(square.NewIndex(i, y)) {
			break
		}
	}

	for i := y - 1; i >= 0; i-- {
		if !check(square.NewIndex(x, i)) {
			break
		}
	}
	for i := y + 1; i < 8; i++ {
		if !check(square.NewIndex(x, i)) {
			break
		}
	}
	return tos
}

func (board Board) {Color}Tos(s square.Index, kingSquare square.Index) square.Indexes {
	if board[s] == {Color}King {
		return board.{Color}KingTos(s)
	}
	if board[s] == {Color}Rook {
		return board.{Color}RookTos(s, kingSquare)
	}
	if board[s] == {Color}Knight {
		return board.{Color}KnightTos(s, kingSquare)
	}
	return nil
}
